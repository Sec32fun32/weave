"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1388],{56758:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var t=r(85893),o=r(11151);const s={},a="Evaluation Metrics",i={id:"guides/evaluation/scorers",title:"Evaluation Metrics",description:"Evaluations in Weave",source:"@site/docs/guides/evaluation/scorers.md",sourceDirName:"guides/evaluation",slug:"/guides/evaluation/scorers",permalink:"/guides/evaluation/scorers",draft:!1,unlisted:!1,editUrl:"https://github.com/wandb/weave/blob/master/docs/docs/guides/evaluation/scorers.md",tags:[],version:"current",lastUpdatedAt:1730146317e3,frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Evaluations",permalink:"/guides/core-types/evaluations"},next:{title:"Models",permalink:"/guides/core-types/models"}},c={},l=[{value:"Evaluations in Weave",id:"evaluations-in-weave",level:2},{value:"Create your own Scorers",id:"create-your-own-scorers",level:2},{value:"Function-based Scorers",id:"function-based-scorers",level:3},{value:"Class-based Scorers",id:"class-based-scorers",level:3},{value:"How Scorers Work",id:"how-scorers-work",level:2},{value:"Scorer Keyword Arguments",id:"scorer-keyword-arguments",level:3},{value:"Mapping Column Names with column_map",id:"mapping-column-names-with-column_map",level:3},{value:"Final summarization of the scorer",id:"final-summarization-of-the-scorer",level:3},{value:"Predefined Scorers",id:"predefined-scorers",level:2},{value:"<code>HallucinationFreeScorer</code>",id:"hallucinationfreescorer",level:3},{value:"<code>SummarizationScorer</code>",id:"summarizationscorer",level:3},{value:"<code>OpenAIModerationScorer</code>",id:"openaimoderationscorer",level:3},{value:"<code>EmbeddingSimilarityScorer</code>",id:"embeddingsimilarityscorer",level:3},{value:"<code>ValidJSONScorer</code>",id:"validjsonscorer",level:3},{value:"<code>ValidXMLScorer</code>",id:"validxmlscorer",level:3},{value:"<code>PydanticScorer</code>",id:"pydanticscorer",level:3},{value:"RAGAS - <code>ContextEntityRecallScorer</code>",id:"ragas---contextentityrecallscorer",level:3},{value:"RAGAS - <code>ContextRelevancyScorer</code>",id:"ragas---contextrelevancyscorer",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"evaluation-metrics",children:"Evaluation Metrics"}),"\n",(0,t.jsx)(n.h2,{id:"evaluations-in-weave",children:"Evaluations in Weave"}),"\n",(0,t.jsx)(n.p,{children:"In Weave, Scorers are used to evaluate AI outputs and return evaluation metrics. They take the AI's output, analyze it, and return a dictionary of results. Scorers can use your input data as reference if needed and can also output extra information, such as explanations or reasonings from the evaluation."}),"\n",(0,t.jsxs)(n.p,{children:["Scorers are passed to a ",(0,t.jsx)(n.code,{children:"weave.Evaluation"})," object during evaluation. There are two types of Scorers in weave:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Function-based Scorers:"})," Simple Python functions decorated with ",(0,t.jsx)(n.code,{children:"@weave.op"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Class-based Scorers:"})," Python classes that inherit from ",(0,t.jsx)(n.code,{children:"weave.Scorer"})," for more complex evaluations."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Scorers must return a dictionary and can return multiple metrics, nested metrics and non-numeric values such as text returned from a LLM-evaluator about its reasoning."}),"\n",(0,t.jsx)(n.h2,{id:"create-your-own-scorers",children:"Create your own Scorers"}),"\n",(0,t.jsx)(n.h3,{id:"function-based-scorers",children:"Function-based Scorers"}),"\n",(0,t.jsxs)(n.p,{children:["These are functions decorated with ",(0,t.jsx)(n.code,{children:"@weave.op"})," that return a dictionary. They're great for simple evaluations like:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import weave\n\n@weave.op\ndef evaluate_uppercase(text: str) -> dict:  # Added return type hint\n    return {"text_is_uppercase": text.isupper()}\n\nmy_eval = weave.Evaluation(\n    dataset=[{"text": "HELLO WORLD"}], \n    scorers=[evaluate_uppercase]\n)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["When the evaluation is run, ",(0,t.jsx)(n.code,{children:"evaluate_uppercase"})," checks if the text is all uppercase."]}),"\n",(0,t.jsx)(n.h3,{id:"class-based-scorers",children:"Class-based Scorers"}),"\n",(0,t.jsxs)(n.p,{children:["For more advanced evaluations, especially when you need to keep track of additional scorer metadata, try different prompts for your LLM-evaluators, or make multiple function calls, you can use the ",(0,t.jsx)(n.code,{children:"Scorer"})," class."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Inherit from ",(0,t.jsx)(n.code,{children:"weave.Scorer"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Define a ",(0,t.jsx)(n.code,{children:"score"})," method decorated with ",(0,t.jsx)(n.code,{children:"@weave.op"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"score"})," method must return a dictionary."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import weave\nfrom openai import OpenAI\nfrom weave import Scorer\n\nllm_client = OpenAI()\n\n#highlight-next-line\nclass SummarizationScorer(Scorer):\n    model_id: str = "gpt-4o"\n    system_prompt: str = "Evaluate whether the summary is good."\n\n    @weave.op\n    def some_complicated_preprocessing(self, text: str) -> str:\n        processed_text = "Original text: \\n" + text + "\\n"\n        return processed_text\n\n    @weave.op\n    def call_llm(self, summary: str, processed_text: str) -> dict:\n        res = llm_client.chat.completions.create(\n            messages=[\n                {"role": "system", "content": self.system_prompt},\n                {"role": "user", "content": (\n                    f"Analyse how good the summary is compared to the original text." \n                    f"Summary: {summary}\\n{processed_text}"\n                )}])\n        return {"summary_quality": res}\n\n    @weave.op\n    def score(self, output: str, text: str) -> dict:\n        """Score the summary quality.\n\n        Args:\n            output: The summary generated by an AI system\n            text: The original text being summarized\n        """\n        processed_text = self.some_complicated_preprocessing(text)\n        eval_result = self.call_llm(summary=output, processed_text=processed_text)\n        return {"summary_quality": eval_result}\n\nevaluation = weave.Evaluation(\n    dataset=[{"text": "The quick brown fox jumps over the lazy dog."}], \n    scorers=[summarization_scorer])\n'})}),"\n",(0,t.jsx)(n.p,{children:"This class evaluates how good a summary is by comparing it to the original text."}),"\n",(0,t.jsx)(n.h2,{id:"how-scorers-work",children:"How Scorers Work"}),"\n",(0,t.jsx)(n.h3,{id:"scorer-keyword-arguments",children:"Scorer Keyword Arguments"}),"\n",(0,t.jsx)(n.p,{children:"Scorers can access both the output from your AI system and the input data from the dataset row."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Input:"}),' If you would like your scorer to use data from your dataset row, such as a "label" or "target" column then you can easily make this available to the scorer by adding a ',(0,t.jsx)(n.code,{children:"label"})," or ",(0,t.jsx)(n.code,{children:"target"})," keyword argument to your scorer definition."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:['For example if you wanted to use a column called "label" from your dataset then your scorer function (or ',(0,t.jsx)(n.code,{children:"score"})," class method) would have a parameter list like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"@weave.op\ndef my_custom_scorer(output: str, label: int) -> dict:  # Added return type hint\n    ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When a weave ",(0,t.jsx)(n.code,{children:"Evaluation"})," is run, the output of the AI system is passed to the ",(0,t.jsx)(n.code,{children:"output"})," parameter. The ",(0,t.jsx)(n.code,{children:"Evaluation"})," also automatically tries to match any additional scorer argument names to your dataset columns. If customizing your scorer arguments or dataset columns is not feasible, you can use column mapping - see below for more."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Output:"})," Include an ",(0,t.jsx)(n.code,{children:"output"})," parameter in your scorer function's signature to access the AI system's output."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mapping-column-names-with-column_map",children:"Mapping Column Names with column_map"}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes, the ",(0,t.jsx)(n.code,{children:"score"})," methods' argument names don't match the column names in your dataset. You can fix this using a ",(0,t.jsx)(n.code,{children:"column_map"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If you're using a class-based scorer, pass a dictionary to the ",(0,t.jsx)(n.code,{children:"column_map"})," attribute of ",(0,t.jsx)(n.code,{children:"Scorer"})," when you initialise your scorer class. This dictionary maps your ",(0,t.jsx)(n.code,{children:"score"})," method's  argument names to the dataset's column names, in the order: ",(0,t.jsx)(n.code,{children:"{scorer_keyword_argument: dataset_column_name}"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import weave\nfrom weave import Scorer\n\n# A dataset with news articles to be summarised\ndataset = [\n    {"news_article": "The news today was great...", "date": "2030-04-20", "source": "Bright Sky Network"},\n    ...\n]\n\n# Scorer class\nclass SummarizationScorer(Scorer):\n    \n    @weave.op\n    def score(output, text) -> dict:\n        """\n            output: output summary from a LLM summarization system\n            text: the text being summarised\n        """\n        ...  # evaluate the quality of the summary\n\n# create a scorer with a column mapping the `text` argument to the `news_article` data column\nscorer = SummarizationScorer(column_map={"text" : "news_article"})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now, the ",(0,t.jsx)(n.code,{children:"text"})," argument in the ",(0,t.jsx)(n.code,{children:"score"})," method will receive data from the ",(0,t.jsx)(n.code,{children:"news_article"})," dataset column."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Another equivalent option to map your columns is to subclass the ",(0,t.jsx)(n.code,{children:"Scorer"})," and overload the ",(0,t.jsx)(n.code,{children:"score"})," method mapping the columns explicitly."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import weave\nfrom weave import Scorer\n\nclass MySummarizationScorer(SummarizationScorer):\n    \n    @weave.op\n    def score(self, output: str, news_article: str) -> dict:  # Added type hints\n        # overload the score method and map columns manually\n        return super().score(output=output, text=news_article)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"final-summarization-of-the-scorer",children:"Final summarization of the scorer"}),"\n",(0,t.jsxs)(n.p,{children:["During evaluation, the scorer will be computed for each row of your dataset. To provide a final score for the evaluation we provide an ",(0,t.jsx)(n.code,{children:"auto_summarize"})," depending on the returning type of the output."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"average will be computed for numerical columns"}),"\n",(0,t.jsx)(n.li,{children:"count and fraction for boolean cols"}),"\n",(0,t.jsx)(n.li,{children:"other col types are ignored"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You can override the ",(0,t.jsx)(n.code,{children:"summarize"})," method on the ",(0,t.jsx)(n.code,{children:"Scorer"})," class and provide your own way of computing the final scores. The ",(0,t.jsx)(n.code,{children:"summarize"})," function expects:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A single parameter ",(0,t.jsx)(n.code,{children:"score_rows"}),": This is a list of dictionaries, where each dictionary contains the scores returned by the ",(0,t.jsx)(n.code,{children:"score"})," method for a single row of your dataset."]}),"\n",(0,t.jsx)(n.li,{children:"It should return a dictionary containing the summarized scores."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why this is useful?"})}),"\n",(0,t.jsx)(n.p,{children:"When you need to score all rows before deciding on the final value of the score for the dataset."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class MyBinaryScorer(Scorer):\n    """\n    Returns True if the full output matches the target, False if not\n    """\n    \n    @weave.op\n    def score(output, target):\n        return {"match": if output == target}\n\n    def summarize(self, score_rows: list) -> dict:\n        full_match = all(row["match"] for row in score_rows)\n        return {"full_match": full_match}\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["In this example, the default ",(0,t.jsx)(n.code,{children:"auto_summarize"})," would have returned the count and proportion of True."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you want to learn more, check the implementation of ",(0,t.jsx)(n.a,{href:"/tutorial-rag#optional-defining-a-scorer-class",children:"CorrectnessLLMJudge"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"predefined-scorers",children:"Predefined Scorers"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Installation"})}),"\n",(0,t.jsx)(n.p,{children:"To use Weave's predefined scorers you need to install some additional dependencies:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"pip install weave[scorers]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"LLM-evaluators"})}),"\n",(0,t.jsxs)(n.p,{children:["The pre-defined scorers that use LLMs support the OpenAI, Anthropic, Google GenerativeAI and MistralAI clients. They also use ",(0,t.jsx)(n.code,{children:"weave"}),"'s ",(0,t.jsx)(n.code,{children:"InstructorLLMScorer"})," class, so you'll need to install the ",(0,t.jsx)(n.a,{href:"https://github.com/instructor-ai/instructor",children:(0,t.jsx)(n.code,{children:"instructor"})})," Python package to be able to use them.  You can get all necessary dependencies with ",(0,t.jsx)(n.code,{children:'pip install "weave[scorers]"'})]}),"\n",(0,t.jsx)(n.h3,{id:"hallucinationfreescorer",children:(0,t.jsx)(n.code,{children:"HallucinationFreeScorer"})}),"\n",(0,t.jsx)(n.p,{children:"This scorer checks if your AI system's output includes any hallucinations based on the input data."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from weave.scorers import HallucinationFreeScorer\n\nllm_client = ... # initialize your LLM client here\n\nscorer = HallucinationFreeScorer(\n    client=llm_client, \n    model_id="gpt4o"\n)\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Customization:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Customize the ",(0,t.jsx)(n.code,{children:"system_prompt"})," and ",(0,t.jsx)(n.code,{children:"user_prompt"}),' attributes of the scorer to define what "hallucination" means for you.']}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"score"})," method expects an input column named ",(0,t.jsx)(n.code,{children:"context"}),". If your dataset uses a different name, use the ",(0,t.jsx)(n.code,{children:"column_map"})," attribute to map ",(0,t.jsx)(n.code,{children:"context"})," to the dataset column."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here you have an example in the context of an evaluation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import asyncio\nfrom openai import OpenAI\nimport weave\nfrom weave.scorers import HallucinationFreeScorer\n\n# Initialize clients and scorers\nllm_client = OpenAI()\nhallucination_scorer = HallucinationFreeScorer(\n    client=llm_client, \n    model_id="gpt-4o",\n    column_map={"context": "input", "output": "other_col"}\n)\n\n# Create dataset\ndataset = [\n    {"input": "John likes various types of cheese."},\n    {"input": "Pepe likes various types of cheese."},\n]\n\n@weave.op\ndef model(input: str) -> str:\n    return "The person\'s favorite cheese is cheddar."\n\n# Run evaluation\nevaluation = weave.Evaluation(\n    dataset=dataset,\n    scorers=[hallucination_scorer],\n)\nresult = asyncio.run(evaluation.evaluate(model))\nprint(result)\n# {\'HallucinationFreeScorer\': {\'has_hallucination\': {\'true_count\': 2, \'true_fraction\': 1.0}}, \'model_latency\': {\'mean\': 1.4395725727081299}}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"summarizationscorer",children:(0,t.jsx)(n.code,{children:"SummarizationScorer"})}),"\n",(0,t.jsx)(n.p,{children:"Use an LLM to compare a summary to the original text and evaluate the quality of the summary."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from weave.scorers import SummarizationScorer\n\nllm_client = ... # initialize your LLM client here\n\nscorer = SummarizationScorer(\n    client=llm_client, \n    model_id="gpt4o"\n)\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How It Works:"})}),"\n",(0,t.jsx)(n.p,{children:"This scorer evaluates summaries in two ways:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Entity Density:"}),' Checks the ratio of unique entities (like names, places, or things) mentioned in the summary to the total word count in the summary in order to estimate the "information density" of the summary. Uses an LLM to extract the entities. Similar to how entity density is used in the Chain of Density paper, ',(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2309.04269",children:"https://arxiv.org/abs/2309.04269"})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Quality Grading:"})," Uses an LLM-evaluator to grade the summary as ",(0,t.jsx)(n.code,{children:"poor"}),", ",(0,t.jsx)(n.code,{children:"ok"}),", or ",(0,t.jsx)(n.code,{children:"excellent"}),". These grades are converted to scores (0.0 for poor, 0.5 for ok, and 1.0 for excellent) so you can calculate averages."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Customization:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Adjust ",(0,t.jsx)(n.code,{children:"summarization_evaluation_system_prompt"})," and ",(0,t.jsx)(n.code,{children:"summarization_evaluation_prompt"})," to define what makes a good summary."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["This scorer uses the ",(0,t.jsx)(n.code,{children:"InstructorLLMScorer"})," class."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"score"})," method expects the original text that was summarized to be present in the ",(0,t.jsx)(n.code,{children:"input"})," column of the dataset. Use the ",(0,t.jsx)(n.code,{children:"column_map"})," class attribute to map ",(0,t.jsx)(n.code,{children:"input"})," to the correct dataset column if needed."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Here you have an example usage of the ",(0,t.jsx)(n.code,{children:"SummarizationScorer"})," in the context of an evaluation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import asyncio\nfrom openai import OpenAI\nimport weave\nfrom weave.scorers import SummarizationScorer\n\nclass SummarizationModel(weave.Model):\n    @weave.op()\n    async def predict(self, input: str) -> str:\n        return \"This is a summary of the input text.\"\n\n# Initialize clients and scorers\nllm_client = OpenAI()\nmodel = SummarizationModel()\nsummarization_scorer = SummarizationScorer(\n    client=llm_client, \n    model_id=\"gpt-4o\",\n)\n# Create dataset\ndataset = [\n    {\"input\": \"The quick brown fox jumps over the lazy dog.\"},\n    {\"input\": \"Artificial Intelligence is revolutionizing various industries.\"}\n]\n\n# Run evaluation\nevaluation = weave.Evaluation(dataset=dataset, scorers=[summarization_scorer])\nresults = asyncio.run(evaluation.evaluate(model))\nprint(results)\n# {'SummarizationScorer': {'is_entity_dense': {'true_count': 0, 'true_fraction': 0.0}, 'summarization_eval_score': {'mean': 0.0}, 'entity_density': {'mean': 0.0}}, 'model_latency': {'mean': 6.210803985595703e-05}}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"openaimoderationscorer",children:(0,t.jsx)(n.code,{children:"OpenAIModerationScorer"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"OpenAIModerationScorer"})," uses OpenAI's Moderation API to check if the AI system's output contains disallowed content, such as hate speech or explicit material."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from weave.scorers import OpenAIModerationScorer\nfrom openai import OpenAI\n\noai_client = OpenAI(api_key=...) # initialize your LLM client here\n\nscorer = OpenAIModerationScorer(\n    client=oai_client,\n    model_id="text-embedding-3-small"\n)\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How It Works:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Sends the AI's output to the OpenAI Moderation endpoint and returns a dictionary indicating whether the content is flagged and details about the categories involved."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Requires the ",(0,t.jsx)(n.code,{children:"openai"})," Python package."]}),"\n",(0,t.jsxs)(n.li,{children:["The client must be an instance of OpenAI's ",(0,t.jsx)(n.code,{children:"OpenAI"})," or ",(0,t.jsx)(n.code,{children:"AsyncOpenAI"})," client."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here you have an example in the context of an evaluation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import asyncio\nfrom openai import OpenAI\nimport weave\nfrom weave.scorers import OpenAIModerationScorer\n\nclass MyModel(weave.Model):\n    @weave.op\n    async def predict(self, input: str) -> str:\n        return input\n\n# Initialize clients and scorers\nclient = OpenAI()\nmodel = MyModel()\nmoderation_scorer = OpenAIModerationScorer(client=client)\n\n# Create dataset\ndataset = [\n    {\"input\": \"I love puppies and kittens!\"},\n    {\"input\": \"I hate everyone and want to hurt them.\"}\n]\n\n# Run evaluation\nevaluation = weave.Evaluation(dataset=dataset, scorers=[moderation_scorer])\nresults = asyncio.run(evaluation.evaluate(model))\nprint(results)\n# {'OpenAIModerationScorer': {'flagged': {'true_count': 1, 'true_fraction': 0.5}, 'categories': {'violence': {'true_count': 1, 'true_fraction': 1.0}}}, 'model_latency': {'mean': 9.500980377197266e-05}}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"embeddingsimilarityscorer",children:(0,t.jsx)(n.code,{children:"EmbeddingSimilarityScorer"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"EmbeddingSimilarityScorer"})," computes the cosine similarity between the embeddings of the AI system's output and a target text from your dataset. It's useful for measuring how similar the AI's output is to a reference text."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from weave.scorers import EmbeddingSimilarityScorer\n\nllm_client = ...  # initialise your LlM client\n\nsimilarity_scorer = EmbeddingSimilarityScorer(\n    client=llm_client\n    target_column="reference_text",  # the dataset column to compare the output against\n    threshold=0.4  # the cosine similarity threshold to use  \n)\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"target"}),": This scorer expects a ",(0,t.jsx)(n.code,{children:"target"})," column in your dataset, it will calculate the cosine similarity of the embeddings of the ",(0,t.jsx)(n.code,{children:"target"})," column to the AI system output. If your dataset doesn't contain a column called ",(0,t.jsx)(n.code,{children:"target"})," you can use the scorers ",(0,t.jsx)(n.code,{children:"column_map"})," attribute to map ",(0,t.jsx)(n.code,{children:"target"})," to the appropriate column name in your dataset. See the Column Mapping section for more."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"threshold"})," (float): The minimum cosine similarity score between the embedding of the AI system output and the embdedding of the ",(0,t.jsx)(n.code,{children:"target"}),', above which the 2 samples are considered "similar", (defaults to ',(0,t.jsx)(n.code,{children:"0.5"}),"). ",(0,t.jsx)(n.code,{children:"threshold"})," can be in a range from -1 to 1:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"1 indicates identical direction."}),"\n",(0,t.jsx)(n.li,{children:"0 indicates orthogonal vectors."}),"\n",(0,t.jsx)(n.li,{children:"-1 indicates opposite direction."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The correct cosine similarity threshold to set can fluctuate quite a lot depending on your use case, we advise exploring different thresholds."}),"\n",(0,t.jsxs)(n.p,{children:["Here you have an example usage of the ",(0,t.jsx)(n.code,{children:"EmbeddingSimilarityScorer"})," in the context of an evaluation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import asyncio\nfrom openai import OpenAI\nimport weave\nfrom weave.scorers import EmbeddingSimilarityScorer\n\n# Initialize clients and scorers\nclient = OpenAI()\nsimilarity_scorer = EmbeddingSimilarityScorer(\n    client=client,\n    threshold=0.7,\n    column_map={"target": "reference"}\n)\n\n# Create dataset\ndataset = [\n    {\n        "input": "He\'s name is John",\n        "reference": "John likes various types of cheese.",\n    },\n    {\n        "input": "He\'s name is Pepe.",\n        "reference": "Pepe likes various types of cheese.",\n    },\n]\n\n# Define model\n@weave.op\ndef model(input: str) -> str:\n    return "John likes various types of cheese."\n\n# Run evaluation\nevaluation = weave.Evaluation(\n    dataset=dataset,\n    scorers=[similarity_scorer],\n)\nresult = asyncio.run(evaluation.evaluate(model))\nprint(result)\n# {\'EmbeddingSimilarityScorer\': {\'is_similar\': {\'true_count\': 1, \'true_fraction\': 0.5}, \'similarity_score\': {\'mean\': 0.8448514031462045}}, \'model_latency\': {\'mean\': 0.45862746238708496}}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"validjsonscorer",children:(0,t.jsx)(n.code,{children:"ValidJSONScorer"})}),"\n",(0,t.jsx)(n.p,{children:"The ValidJSONScorer checks whether the AI system's output is valid JSON. This scorer is useful when you expect the output to be in JSON format and need to verify its validity."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from weave.scorers import ValidJSONScorer\n\njson_scorer = ValidJSONScorer()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Here you have an example usage of the ",(0,t.jsx)(n.code,{children:"ValidJSONScorer"})," in the context of an evaluation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import asyncio\nimport weave\nfrom weave.scorers import ValidJSONScorer\n\nclass JSONModel(weave.Model):\n    @weave.op()\n    async def predict(self, input: str) -> str:\n        # This is a placeholder. \n        # In a real scenario, this would generate JSON.\n        return '{\"key\": \"value\"}'\n\nmodel = JSONModel()\njson_scorer = ValidJSONScorer()\n\ndataset = [\n    {\"input\": \"Generate a JSON object with a key and value\"},\n    {\"input\": \"Create an invalid JSON\"}\n]\n\nevaluation = weave.Evaluation(dataset=dataset, scorers=[json_scorer])\nresults = asyncio.run(evaluation.evaluate(model))\nprint(results)\n# {'ValidJSONScorer': {'json_valid': {'true_count': 2, 'true_fraction': 1.0}}, 'model_latency': {'mean': 8.58306884765625e-05}}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"validxmlscorer",children:(0,t.jsx)(n.code,{children:"ValidXMLScorer"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ValidXMLScorer"})," checks whether the AI system's output is valid XML. This is useful when expecting XML-formatted outputs."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from weave.scorers import ValidXMLScorer\n\nxml_scorer = ValidXMLScorer()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Here you have an example usage of the ",(0,t.jsx)(n.code,{children:"ValidXMLScorer"})," in the context of an evaluation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import asyncio\nimport weave\nfrom weave.scorers import ValidXMLScorer\n\nclass XMLModel(weave.Model):\n    @weave.op()\n    async def predict(self, input: str) -> str:\n        # This is a placeholder. In a real scenario, this would generate XML.\n        return '<root><element>value</element></root>'\n\nmodel = XMLModel()\nxml_scorer = ValidXMLScorer()\n\ndataset = [\n    {\"input\": \"Generate a valid XML with a root element\"},\n    {\"input\": \"Create an invalid XML\"}\n]\n\nevaluation = weave.Evaluation(dataset=dataset, scorers=[xml_scorer])\nresults = asyncio.run(evaluation.evaluate(model))\nprint(results)\n# {'ValidXMLScorer': {'xml_valid': {'true_count': 2, 'true_fraction': 1.0}}, 'model_latency': {'mean': 8.20159912109375e-05}}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"pydanticscorer",children:(0,t.jsx)(n.code,{children:"PydanticScorer"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"PydanticScorer"})," validates the AI system's output against a Pydantic model to ensure it adheres to a specified schema or data structure."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from weave.scorers import PydanticScorer\nfrom pydantic import BaseModel\n\nclass FinancialReport(BaseModel):\n    revenue: int\n    year: str\n\npydantic_scorer = PydanticScorer(model=FinancialReport)\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"ragas---contextentityrecallscorer",children:["RAGAS - ",(0,t.jsx)(n.code,{children:"ContextEntityRecallScorer"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ContextEntityRecallScorer"})," estimates context recall by extracting entities from both the AI system's output and the provided context, then computing the recall score. Based on the ",(0,t.jsx)(n.a,{href:"https://github.com/explodinggradients/ragas",children:"RAGAS"})," evaluation library"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from weave.scorers import ContextEntityRecallScorer\n\nllm_client = ...  # initialise your LlM client\n\nentity_recall_scorer = ContextEntityRecallScorer(\n    client=llm_client\n    model_id="your-model-id"\n)\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How It Works:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Uses an LLM to extract unique entities from the output and context and calculates recall."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recall"})," indicates the proportion of important entities from the context that are captured in the output, helping to assess the model's effectiveness in retrieving relevant information."]}),"\n",(0,t.jsx)(n.li,{children:"Returns a dictionary with the recall score."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Expects a ",(0,t.jsx)(n.code,{children:"context"})," column in your dataset, use ",(0,t.jsx)(n.code,{children:"column_map"})," to map ",(0,t.jsx)(n.code,{children:"context"})," to another dataset column if needed."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"ragas---contextrelevancyscorer",children:["RAGAS - ",(0,t.jsx)(n.code,{children:"ContextRelevancyScorer"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ContextRelevancyScorer"})," evaluates the relevancy of the provided context to the AI system's output. It helps determine if the context used is appropriate for generating the output. Based on the ",(0,t.jsx)(n.a,{href:"https://github.com/explodinggradients/ragas",children:"RAGAS"})," evaluation library."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from weave.scorers import ContextRelevancyScorer\n\nllm_client = ...  # initialise your LlM client\n\nrelevancy_scorer = ContextRelevancyScorer(\n    llm_client = ...  # initialise your LlM client\n    model_id="your-model-id"\n    )\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How It Works:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Uses an LLM to rate the relevancy of the context to the output on a scale from 0 to 1."}),"\n",(0,t.jsxs)(n.li,{children:["Returns a dictionary with the ",(0,t.jsx)(n.code,{children:"relevancy_score"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Expects a ",(0,t.jsx)(n.code,{children:"context"})," column in your dataset, use ",(0,t.jsx)(n.code,{children:"column_map"})," to map ",(0,t.jsx)(n.code,{children:"context"})," to another dataset column if needed."]}),"\n",(0,t.jsxs)(n.li,{children:["Customize the ",(0,t.jsx)(n.code,{children:"relevancy_prompt"})," to define how relevancy is assessed."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Here you have an example usage of ",(0,t.jsx)(n.code,{children:"ContextEntityRecallScorer"})," and ",(0,t.jsx)(n.code,{children:"ContextRelevancyScorer"})," in the context of an evaluation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import asyncio\nfrom textwrap import dedent\nfrom openai import OpenAI\nimport weave\nfrom weave.scorers import ContextEntityRecallScorer, ContextRelevancyScorer\n\nclass RAGModel(weave.Model):\n    @weave.op()\n    async def predict(self, question: str) -> str:\n        "Retrieve relevant context"\n        return "Paris is the capital of France."\n\n\nmodel = RAGModel()\n\n# Define prompts\nrelevancy_prompt: str = dedent("""\n    Given the following question and context, rate the relevancy of the context to the question on a scale from 0 to 1.\n\n    Question: {question}\n    Context: {context}\n    Relevancy Score (0-1):\n    """)\n\n# Initialize clients and scorers\nllm_client = OpenAI()\nentity_recall_scorer = ContextEntityRecallScorer(\n    client=client,\n    model_id="gpt-4o",\n)\n\nrelevancy_scorer = ContextRelevancyScorer(\n    client=llm_client,\n    model_id="gpt-4o",\n    relevancy_prompt=relevancy_prompt\n)\n\n# Create dataset\ndataset = [\n    {\n        "question": "What is the capital of France?", \n        "context": "Paris is the capital city of France."\n    },\n    {\n        "question": "Who wrote Romeo and Juliet?", \n        "context": "William Shakespeare wrote many famous plays."\n    }\n]\n\n# Run evaluation\nevaluation = weave.Evaluation(\n    dataset=dataset, \n    scorers=[entity_recall_scorer, relevancy_scorer]\n)\nresults = asyncio.run(evaluation.evaluate(model))\nprint(results)\n# {\'ContextEntityRecallScorer\': {\'recall\': {\'mean\': 0.3333333333333333}}, \'ContextRelevancyScorer\': {\'relevancy_score\': {\'mean\': 0.5}}, \'model_latency\': {\'mean\': 9.393692016601562e-05}}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>i,a:()=>a});var t=r(67294);const o={},s=t.createContext(o);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);