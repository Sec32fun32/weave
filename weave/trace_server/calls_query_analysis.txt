Calls Query Structure (considering the merge tree)

Unoptimized form:

SELECT
    {AGG_COLUMNS_REQUESTED}
FROM
    calls_merged
WHERE
    project_id = {PROJECT_ID}
        AND
    {WHERE_CONDITIONS}
GROUP BY
    project_id, id
HAVING
    isNull(deleted_at)
        AND
    {HAVING_CONDITIONS}
ORDER BY
    {ORDER_BY_CLAUSE}
LIMIT
    {LIMIT_CLAUSE}
OFFSET
    {OFFSET_CLAUSE}

----

* sort options:
    (known)
    - started_at
    - ended_at
        (soon)
        - op_name?
        - op_display_name?
        - duration
        - wb_run_id
        - wb_user_id
    (generic)
    - input/output/attribute/summary json query
    - feedback json query

* query/filter options:
    (known)
    - id in list
    - op_name pattern / match
    - input_ref contains
    - output_ref contains
    - trace_id in list
    - parent_id nullish
    - parent_id in list
    - wb_user_id in list
    - wb_run_id in list
        (soon)
        - op_display_name?
        - exception nullish
        - start_time range
        - end_time range
        - duration range
    (generic)
    - input/output/attribute/summary json query
    - feedback json query

* always need to filter out:
    - deleted_at

* need to support limit / offset

---

Approach:
- We will take a layered approach to building the query:
1. (Innermost): Query for IDs matching known filters
2. (Deletion): Account for deleted_at: Note: i think deleted_at needs to be pushed down into the materialized view,
3. (Call Name): This is probably where we would apply the display name filter once avail (sad)
4. (Feedback): Join on feedback and apply next layer of filters
5. (Dynamic): Filter by passing through refs
    - Adapt the notebook prototype to create a synthetic table based on the needed fields as columns
6. (Sort / Offset / Limit): Apply sorting and pagination
    - Seems like it might benefit from the temp table of layer 5?

Remaining question: can we properly handle ands/ors across part types? Example:
* inputs.a = 1 AND (outputs.b = 2 OR inputs.c = 3)

This approach should eliminate the need for offset, having, and limit on the outside, changing the form to:
---

WITH 
    SIMPLE_FILTERED_IDS_QUERY AS (
        -- This is not ideal. It could be improved under the following conditions:
        -- 1. If we can push down the deleted_at filter into the materialized view
        -- 2. We are able to assume that the table is optimized
        --
        -- If the above conditions where met, then all the conditions could be collapsed
        -- into a single clause, which would remove the need for a full-table scan
        WITH
            SIMPLE_START_PART_FILTERED_IDS_QUERY AS (
                SELECT
                    id
                FROM
                    calls_merged 
                WHERE
                    project_id = {PROJECT_ID}
                        AND
                    isNotNull(started_at)
                        AND
                    {BASIC_WHERE_CONDITIONS_ON_START_PART_FIELDS}
            ),
            SIMPLE_END_PART_FILTERED_IDS_QUERY AS (
                SELECT
                    id
                FROM
                    calls_merged 
                WHERE
                    project_id = {PROJECT_ID}
                        AND
                    isNotNull(ended_at)
                        AND
                    {BASIC_WHERE_CONDITIONS_ON_END_PART_FIELDS}
            ),
            SIMPLE_DELETED_FILTERED_IDS_QUERY AS (
                SELECT
                    id
                FROM
                    calls_merged 
                WHERE
                    project_id = {PROJECT_ID}
                        AND
                    isNotNull(deleted_at)
            )
        SELECT
            id
        FROM
            calls_merged 
        WHERE
            project_id = {PROJECT_ID}
                AND
            id IN (SELECT id FROM SIMPLE_START_PART_FILTERED_IDS_QUERY)
                AND
            id IN (SELECT id FROM SIMPLE_END_PART_FILTERED_IDS_QUERY)
                AND
            id NOT IN (SELECT id FROM SIMPLE_DELETED_FILTERED_IDS_QUERY)
    ),
    -- The goal of the next CTE is is to create a synthetic filter that can be used
    -- to filter and sort the data. In the application layer, we should extract the 
    -- total set of fields that are needed to filter and sort the data, and then
    -- create a synthetic table that has those fields as columns. Again, this
    -- assumes that the table is optimized
    FILTERED_SORTED_HYDRATED_QUERY AS (
        WITH 
            ITERATIVELY_HYDRATED_QUERY (
                SELECT
                    id,
                    ...
                -- This could have many iteratively deep layers here, 
                -- but always terminates at the bottom with the following:
                FROM
                    calls_merged 
                WHERE
                    project_id = {PROJECT_ID}
                        AND
                    id IN (SELECT id FROM SIMPLE_FILTERED_IDS_QUERY)
            )
        SELECT
            id,
            -- These fields might be dynamic fields, feedback fields, or known fields
            query.field.x, 
            query.field.y,
            query.field.z,
            sort.field.x,
            sort.field.y,
            sort.field.z,
            ...
        FROM
            ITERATIVELY_HYDRATED_QUERY
        WHERE
            {WHERE_CONDITIONS}
        ORDER BY
            {ORDER_BY_CLAUSE}
        LIMIT
            {LIMIT_CLAUSE}
        OFFSET
            {OFFSET_CLAUSE}
    )
SELECT
    {AGG_COLUMNS_REQUESTED}
FROM
    calls_merged
WHERE
    project_id = {PROJECT_ID}
        AND
    id IN (SELECT id FROM SORTED_PAGINATED_IDS_QUERY)
GROUP BY
    project_id, id
ORDER BY
    {ORDER_BY_CLAUSE}

----

Let's assume that we don't need to deal with ...


WITH 
    SIMPLE_FILTERED_IDS_QUERY AS (
        SELECT
            project_id,
            id
        FROM
            calls_merged 
        GROUP BY
            project_id, id
        HAVING
            project_id = {PROJECT_ID}
                AND
            {SIMPLE_WHERE_CONDITIONS}
    ),
    -- The goal of the next CTE is is to create a synthetic filter that can be used
    -- to filter and sort the data. In the application layer, we should extract the 
    -- total set of fields that are needed to filter and sort the data, and then
    -- create a synthetic table that has those fields as columns.
    SORTED_PAGINATED_IDS_QUERY AS (
        WITH 
            ITERATIVELY_HYDRATED_QUERY (
                SELECT
                    project_id,
                    id,
                    -- These fields might be dynamic fields, feedback fields, or known fields
                    query.field.x, 
                    query.field.y,
                    query.field.z,
                    sort.field.x,
                    sort.field.y,
                    sort.field.z,
                    ...
                -- This could have many iteratively deep layers here, 
                -- but always terminates at the bottom with the following:
                FROM
                    calls_merged 
                WHERE
                    project_id = {PROJECT_ID}
                        AND
                    id IN (SELECT id FROM SIMPLE_FILTERED_IDS_QUERY)
                GROUP BY
                    project_id, id
            )
        SELECT
            id,
            project_id
        FROM
            ITERATIVELY_HYDRATED_QUERY
        WHERE
            {WHERE_CONDITIONS}
        ORDER BY
            {ORDER_BY_CLAUSE}
        LIMIT
            {LIMIT_CLAUSE}
        OFFSET
            {OFFSET_CLAUSE}
    ),
    PRE_ORDERED_RESULTS AS (
        SELECT
            {AGG_COLUMNS_REQUESTED}
        FROM
            calls_merged
        WHERE
            project_id = {PROJECT_ID}
                AND
            id IN (SELECT id FROM SORTED_PAGINATED_IDS_QUERY)
        GROUP BY
            project_id, id
        -- can we use the ordering calculated in the previous step?
    ),
    -- UGG is this the only way to sort this??
    FINAL_RESULTS AS ( 
        SELECT
            final.*
        FROM
            (
                SELECT
                    id,
                    rowNumberInAllBlocks() as rowNumber
                FROM
                    SORTED_PAGINATED_IDS_QUERY
            ) as sorted
        JOIN
            PRE_ORDERED_RESULTS as final USING (project_id, id)
        ORDER BY
            sorted.rowNumber
    )
SELECT * FROM FINAL_RESULTS
